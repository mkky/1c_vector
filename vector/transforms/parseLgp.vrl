.FilePath = to_string(.file) ?? "unknown"
.FileName = replace!(.FilePath, r'.*[\\/]([^\\/]+)$', "$1")


parsed, err = parse_regex(.message, r'\{(?P<DateTimeRaw>\d{14}),(?P<TransactionStatus>\w),\s*\{(?P<TransactionDate>[^\}]+)\},(?P<User>\d+),(?P<Computer>\d+),(?P<Application>\d+),(?P<Connection>\d+),(?P<Event>\d+),(?P<Severity>\w),"(?P<Comment>[\s\S]*?)",(?P<Metadata>\d+),\s*(?P<Data>[\s\S]+?\}),"(?P<DataPresentation>.*?)",(?P<Server>\d+),(?P<MainPort>\d+),(?P<AddPort>\d+),(?P<Session>\d+)', numeric_groups: false)
if err != null {
  abort
}

. = merge(., parsed)
.name = "JOURNAL_REG"

ts_format = "%Y-%m-%dT%H:%M:%S"
.DateTime =format_timestamp!(parse_timestamp!(.DateTimeRaw, "%Y%m%d%H%M%S"), ts_format, timezone:"UTC")
. = merge(., parse_regex!(.FilePath, r'(?P<db_uid>\w{8}\-\w{4}-\w{4}-\w{4}-\w{12})'))


found_record, err = get_enrichment_table_record("ibases",
  {
   
    "ID": .db_uid,
  }, select: ["name", "Connect_Ref"])
 
if err == null {
  .db_name = found_record.name
  .db_ref = found_record.Connect_Ref
}



# 4. описываем, какие поля и в какой type из lgf.csv перевести
enrich_map = {
  "User":        "users",
  "Computer":    "computers",
  "Application": "applications",
  "Event":       "events",
  "Metadata":    "metadata",
  "Server":      "servers",
  "MainPort":    "ports",
  "AddPort":     "portsAdd",
}

for_each(keys(enrich_map)) -> |_idx, field| {
  typeName = get!(enrich_map, [field])       # e.g. "users"
  idVal     = to_string(get!(., [field])) ?? ""  # исходный числовой ID
  
  if idVal != "" {
    rec, err = get_enrichment_table_record("lgf",
      {
        "type":   typeName,
        "db_uid": .db_uid,
        "id":     idVal,
      }
    )
    if err == null {
      # Вставляем вместо числа всю запись из lgf.csv
      . = set!(., [field], rec.value)
	  
	  if includes(["Metadata", "User"], field) {
	    . = set!(., [field + "Uuid"], rec.uuid)
	  }

    }
  }
}


ts_map = {
  "N": "Нет транзакции",
  "U": "Зафиксирована",
  "R": "Не завершена",
  "C": "Отменена",
}

sev_map = {
  "I": "Информация",
  "E": "Ошибка",
  "W": "Предупреждение",
  "N": "Примечание",
}

.TransactionStatus = get(ts_map, [.TransactionStatus]) ?? .TransactionStatus
.Severity          = get(sev_map, [.Severity]) ?? .Severity

data_first_value = replace(.Data, r'[\s\S]*\{"\w","([^"]+)"\}[\s\S]*', "$1") ?? .Data
if data_first_value != .Data {
  .Data = data_first_value
  } else {
  .Data = ""
  }


startEpoch = -62135632799

parts         = split!(.TransactionDate, ",")
hexDate       = parts[0]
hexNumber     = parts[1]

if hexDate != "0" && hexDate != "" {
  parsed        = parse_int!(hexDate, base: 16)
  base_ts       = ceil(startEpoch + parsed / 10000)
  corrected_ts  = base_ts + (7 * 3600)
  #ns            = corrected_ts * 1000000000

  .TransactionDate   = format_timestamp!(parse_timestamp!(to_string!(corrected_ts),
                          "%s",),  "%Y-%m-%d %H:%M:%S",
                          timezone: "UTC")


  .TransactionNumber = parse_int!(hexNumber, base: 16)
} else {
  .TransactionDate   = null
}